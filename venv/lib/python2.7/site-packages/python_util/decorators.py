import functools
import signal
import warnings


def deprecated(additional_message=None):
    def deprecator(func=None):
        if not func:
            raise SyntaxError("@deprecated() must be called as a function.")

        msg = "Call to deprecated function {}.".format(func.__name__)
        if additional_message:
            msg += ' ' + additional_message

        def new_function(*args, **kwargs):
            warnings.simplefilter('always', DeprecationWarning)
            warnings.warn_explicit(
                msg,
                category=DeprecationWarning,
                filename=func.__code__.co_filename,
                lineno=func.__code__.co_firstlineno + 1
            )
            warnings.simplefilter('default', DeprecationWarning)

            return func(*args, **kwargs)

        return new_function

    return deprecator


def memoized(obj):
    _cache = obj.cache = {}

    @functools.wraps(obj)
    def memoizer(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in _cache:
            _cache[key] = obj(*args, **kwargs)

        return _cache[key]

    return memoizer


def synchronized(lock):
    def synchronizer(func):
        def new_function(*args, **kw):
            lock.acquire()

            try:
                return func(*args, **kw)
            finally:
                lock.release()

        return new_function

    return synchronizer


class TimeoutError(Exception):
    pass


def timeout(seconds):
    def timer(func):
        def handle_timeout(_signum, _frame):
            raise TimeoutError('Function call timed out')

        @functools.wraps(func)
        def new_function(*args, **kwargs):
            signal.signal(signal.SIGALRM, handle_timeout)
            signal.alarm(seconds)

            try:
                result = func(*args, **kwargs)
            finally:
                signal.alarm(0)

            return result

        return new_function

    return timer
