import collections
import errno
import os

try:
    import cPickle as pickle
except ImportError:
    import pickle


class Pickler(object):
    def __init__(self, default, filename):
        pickledir = os.path.join(
            os.path.dirname(os.path.realpath(__file__)),
            'pickled'
        )

        try:
            os.makedirs(pickledir)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise

        self.filepath = os.path.join(
            pickledir,
            filename
        )

        try:
            with open(self.filepath, 'rb') as f:
                self._store = pickle.load(f)
        except (EOFError, IOError):
            self._store = default

    def save(self):
        # TODO: incremental update
        with open(self.filepath, 'wb') as f:
            pickle.dump(self._store, f)


# TODO: save when calling __setitem__ on result of __getitem__
#       ie. DictPickler()['asdf']['fdsa'] = 42 for nested dicts
class DictPickler(Pickler, collections.MutableMapping):
    def __init__(self, filename):
        Pickler.__init__(self, dict(), filename)

    def __getitem__(self, key):
        return self._store[self.__keytransform__(key)]

    def __setitem__(self, key, value):
        self._store[self.__keytransform__(key)] = value
        self.save()

    def __delitem__(self, key):
        del self._store[self.__keytransform__(key)]
        self.save()

    def __iter__(self):
        return iter(self._store)

    def __len__(self):
        return len(self._store)

    # pylint: disable=R0201
    def __keytransform__(self, key):
        return key

    def __str__(self):
        return self._store.__str__()

    def __repr__(self):
        return self._store.__repr__()


class ObjectPickler(Pickler, object):
    def __init__(self, filename):
        Pickler.__init__(self, None, filename)

    # TODO: deprecate ObjPic.store for ObjPic
    @property
    def store(self):
        return self._store

    @store.setter
    def store(self, value):
        self._store = value
        self.save()

    @store.deleter
    def store(self):
        self._store = None
        self.save()
